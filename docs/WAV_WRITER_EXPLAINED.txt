WAV WRITER -- STEP BY STEP
============================


THE BIG PICTURE
---------------

The final step: write the stereo audio (with metronome clicks baked in) to
a WAV file on disk so you can play it in any audio player.

WAV is an uncompressed format -- every sample is stored as a raw number.
No decoding needed on playback, no quality loss. The tradeoff is file size:
a 3-minute stereo track at 44.1 kHz / 16-bit is about 30 MB (vs ~4 MB as
MP3).

The file has two parts: a 44-byte header describing the audio format,
followed by the raw sample data.


Stereo AudioBuffer (float samples, with clicks)
|
+-- Write 44-byte RIFF/WAVE header
|       (sample rate, channels, bit depth, data size)
|
+-- Convert each float sample to 16-bit integer
|       clamp to [-1.0, 1.0], multiply by 32767
|
+-- Write all samples as little-endian 16-bit values
|
+-- output.wav on disk


--------------------------------------------------------------------------------


STEP 1: THE WAV FILE FORMAT
-----------------------------

A WAV file is a RIFF container with a WAVE payload. The header is always
exactly 44 bytes for standard PCM audio (no compression, no extra metadata).


Byte layout:

Offset  Size  Field              Value / Meaning
------  ----  -----------------  ----------------------------------
 0      4     ChunkID            "RIFF"  (marks this as a RIFF file)
 4      4     ChunkSize          36 + data_bytes  (file size minus 8)
 8      4     Format             "WAVE"  (RIFF type)
12      4     Subchunk1ID        "fmt "  (format sub-chunk)
16      4     Subchunk1Size      16  (size of fmt data that follows)
20      2     AudioFormat        1  (PCM = uncompressed)
22      2     NumChannels        2  (stereo)
24      4     SampleRate         44100
28      4     ByteRate           176400  (SampleRate * NumChannels * BitsPerSample/8)
32      2     BlockAlign         4  (NumChannels * BitsPerSample/8)
34      2     BitsPerSample      16
36      4     Subchunk2ID        "data"  (data sub-chunk)
40      4     Subchunk2Size      data_bytes  (NumSamples * BitsPerSample/8)
44      ...   Data               the actual audio samples


Visually:

+------+------------+------+------+-----------+---+---+-------+--------+
| RIFF | chunk size | WAVE | fmt  | fmt size  | 1 | 2 | 44100 | 176400 |
+------+------------+------+------+-----------+---+---+-------+--------+
  4B       4B         4B     4B      4B        2B  2B    4B       4B

+---+----+------+-----------+-----------------------------
| 4 | 16 | data | data size | sample sample sample ...
+---+----+------+-----------+-----------------------------
 2B   2B   4B      4B          N * 2 bytes


All multi-byte numbers are stored in little-endian byte order (least
significant byte first). This is the native byte order on x86/ARM, so
on most machines the bytes can be written directly without swapping.


Example: the 32-bit value 44100 (0x0000AC44) is stored as:

    Byte 0: 0x44  (least significant)
    Byte 1: 0xAC
    Byte 2: 0x00
    Byte 3: 0x00  (most significant)


The header fields are interdependent:

    BlockAlign = NumChannels * (BitsPerSample / 8)
               = 2 * (16 / 8)
               = 4 bytes per sample frame

    ByteRate   = SampleRate * BlockAlign
               = 44100 * 4
               = 176400 bytes per second of audio

    ChunkSize  = 36 + Subchunk2Size
               = 36 + (total_samples * 2)

    These tell the player how to read the data: "advance 4 bytes per frame,
    consume 176400 bytes per second, and the data region is this many bytes."


--------------------------------------------------------------------------------


STEP 2: FLOAT TO 16-BIT INTEGER CONVERSION
--------------------------------------------

Our audio is stored as 32-bit floats in the range [-1.0, +1.0]. WAV PCM
files use 16-bit signed integers in the range [-32768, +32767].

Conversion for each sample:

    1. Clamp to [-1.0, +1.0]  (should already be clamped from metronome step,
       but done again for safety)
    2. Multiply by 32767
    3. Cast to 16-bit signed integer

Examples:

    Float        Clamped     * 32767     Int16
    -----        -------     -------     -----
     1.0          1.0         32767      32767   (maximum positive)
     0.5          0.5         16383      16383
     0.0          0.0             0          0   (silence)
    -0.5         -0.5        -16383     -16383
    -1.0         -1.0        -32767     -32767   (maximum negative)
     1.35         1.0         32767      32767   (clamped!)
    -1.2         -1.0        -32767     -32767   (clamped!)


Why 32767 and not 32768?

The 16-bit signed integer range is [-32768, +32767] -- it's asymmetric.
Using 32767 as the multiplier ensures that +1.0 maps to +32767 and -1.0
maps to -32767, keeping the output symmetric. Multiplying by 32768 would
risk integer overflow at +1.0.


Quantization noise:

The step from float to int16 discards precision. The smallest representable
step is 1/32767 = 0.0000305. This introduces quantization noise at about
-96 dB below full scale -- far below audible for a diagnostic click track.


--------------------------------------------------------------------------------


STEP 3: WRITING THE SAMPLES
-----------------------------

The int16 sample values are written in little-endian byte order, interleaved
by channel (same layout as the original decode):

    L0 R0 L1 R1 L2 R2 L3 R3 ...

Each sample is 2 bytes (16 bits), written least-significant byte first.


Example: writing the int16 value 16383 (0x3FFF):

    Byte 0: 0xFF  (least significant)
    Byte 1: 0x3F  (most significant)

Example: writing the int16 value -16383 (0xC001 in two's complement):

    Byte 0: 0x01  (least significant)
    Byte 1: 0xC0  (most significant)


For a 3-minute stereo song at 44.1 kHz:

    Frames:       3 * 60 * 44100 = 7,938,000
    Samples:      7,938,000 * 2 channels = 15,876,000
    Data bytes:   15,876,000 * 2 bytes = 31,752,000 bytes
    Total file:   44 + 31,752,000 = ~30.3 MB


--------------------------------------------------------------------------------


WHY WAV AND NOT MP3?
---------------------

WAV is the simplest possible output format:
    - No compression library needed (MP3 encoding would require LAME or
      similar).
    - No quality loss from re-encoding.
    - Universally playable on every OS and audio player.
    - Header format is trivial to implement (44 bytes of fixed fields).

The downside is size (~30 MB vs ~4 MB for MP3), but for a diagnostic tool
where you're listening to verify beat detection accuracy, this is fine.


--------------------------------------------------------------------------------


PUTTING IT ALL TOGETHER
------------------------

    Stereo AudioBuffer:  15,876,000 float samples
                         sample_rate = 44100, channels = 2
        |
        v
    Write header (44 bytes):
        "RIFF" | 31752036 | "WAVE"
        "fmt " | 16 | 1 | 2 | 44100 | 176400 | 4 | 16
        "data" | 31752000
        |
        v
    For each float sample:
        clamp to [-1.0, 1.0]
        int16_value = float * 32767
        write 2 bytes (little-endian)
        |
        v
    output.wav  (30.3 MB, playable immediately)
