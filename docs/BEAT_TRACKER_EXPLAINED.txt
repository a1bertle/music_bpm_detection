BEAT TRACKER -- STEP BY STEP
==============================


THE BIG PICTURE
---------------

The tempo estimator told us HOW FAST the song is (e.g. 120 BPM, period = 43
frames). But it didn't tell us WHERE each beat lands. A 120 BPM song has a
beat every 0.5 seconds, but the first beat could start at 0.0s, or 0.1s, or
0.23s -- any phase offset is possible.

The beat tracker solves this: given the onset strength function O[n] and the
estimated period T, find the exact sequence of frames where beats occur.


Input:
    - O[n]: onset strength per frame (from onset detector)
    - T: beat period in frames (from tempo estimator, e.g. 43)

Output:
    - List of beat positions in samples (e.g. [5120, 27136, 49152, ...])


Onset strength O[n]  +  period T
|
+-- Forward pass (dynamic programming) --> Score every frame as a
|                                           potential beat, considering
|                                           all possible predecessors
|
+-- Backtrace ---------------------------> Follow the chain of best
|                                           predecessors from end to start
|
+-- Convert frames to samples -----------> frame * hop_size


--------------------------------------------------------------------------------


WHY NOT JUST PICK THE PEAKS?

A naive approach would be: find all peaks in O[n] that are roughly T frames
apart. But this fails:

O[n]
|
|     #        #     #        #        #     #        #
|     #   #    #     #   #    #   #    #     #   #    #
|  #  #   #    #  #  #   #    #   #    #  #  #   #    #
+--#--#---#----#--#--#---#----#---#----#--#--#---#----#-----> frames
   |  |   |    |  |  |   |    |   |    |  |  |   |    |
   ?  ?   ?    ?  ?  ?   ?    ?   ?    ?  ?  ?   ?    ?

Which peaks are beats? There are too many peaks (hi-hats, ghost notes, etc.)
and some beats might not even have strong peaks (a rest on the beat, a
syncopated rhythm). You need a method that finds the BEST OVERALL sequence --
not just local peaks -- balancing two goals:

    1. Beats should land on strong onsets (high O[n]).
    2. Beats should be evenly spaced at period T.

These goals can conflict. Sometimes the best overall sequence skips a strong
peak to maintain regularity, or places a beat on a weak frame to keep the
spacing consistent.


--------------------------------------------------------------------------------


STEP 1: THE SCORE FUNCTION (DYNAMIC PROGRAMMING)
--------------------------------------------------

Dynamic programming (DP) finds the globally optimal beat sequence by building
up solutions from left to right.

For each frame t, we compute:

    dp[t] = the score of the best beat sequence that ends with a beat at t

The score is:

    dp[t] = max over all valid predecessors p of:

        dp[p]                          score of best sequence ending at p
      + O[t]                           reward: is there an onset here?
      - alpha * (ln(lag / T))^2        penalty: how far is the spacing
                                       from the expected period?

Where:
    lag = t - p   (distance from predecessor to current frame)
    T = expected beat period
    alpha = 680   (controls how strict the regularity is)


The search window for predecessors:

For a given frame t, we don't search ALL previous frames. Only frames within
a reasonable range of the expected period:

    predecessors p in [t - 2*T,  t - T/2]

This means the inter-beat interval can range from half the period (double
tempo) to twice the period (half tempo). Anything outside that range would be
too far from the expected tempo to be a valid beat transition.


    <----- search window for predecessors of t ----->
    |                                               |
    t - 2T                                    t - T/2            t
    |                                               |            |
    +-----------------------------------------------+............+
    |  any frame p in here could be the previous beat             |
                                                          current frame


--------------------------------------------------------------------------------


STEP 2: THE PENALTY FUNCTION
------------------------------

The penalty term  alpha * (ln(lag / T))^2  controls beat regularity.

When lag = T (perfect spacing):
    ln(T / T) = ln(1) = 0     -->  penalty = 0

When lag = T/2 (double tempo, half the expected spacing):
    ln(T/2 / T) = ln(0.5) = -0.693  -->  penalty = 680 * 0.48 = 327

When lag = 2T (half tempo, double the expected spacing):
    ln(2T / T) = ln(2) = 0.693  -->  penalty = 680 * 0.48 = 327

The penalty is symmetric in log-space: doubling and halving the period are
penalized equally. Small deviations cost little, large deviations cost a lot:


penalty
  |
  |  *                                     *
  |    *                                 *
  |      *                             *
  |        *                         *
  |          *                     *
  |            **               **
  |              ***         ***
  |                 *********
  +---------+---------+---------+---------> lag
           T/2        T        2T
                      ^
               zero penalty here


The alpha parameter (680) controls how strict this is:

    alpha = 680 (default):  Strong regularity. Beats lock tightly to a grid.
                            Good for pop, rock, electronic.

    alpha = 400 (lower):    More flexible. Allows beats to wander from the
                            grid. Better for classical, jazz, rubato.

    alpha = 1000 (higher):  Very rigid. Almost forces exact period spacing.
                            Only useful for perfectly quantized music.


--------------------------------------------------------------------------------


STEP 3: THE FORWARD PASS
--------------------------

Walk through every frame from left to right. At each frame, try every valid
predecessor and keep the one that gives the best score.


Example with T = 4 frames, alpha = 680:

O[n]:   0.1  0.3  0.1  0.8  0.2  0.1  0.2  0.9  0.1  0.3  0.1  0.7

Frame:    0    1    2    3    4    5    6    7    8    9   10   11
          .    .    .    .    .    .    .    .    .    .    .    .


Frame 0:  No predecessors possible.
          dp[0] = O[0] = 0.1
          prev[0] = -1  (no predecessor)

Frame 1:  No predecessors in valid range (need at least T/2 = 2 frames back).
          dp[1] = O[1] = 0.3
          prev[1] = -1

Frame 3:  Predecessors in [3-8, 3-2] = [0, 1] (clamped to valid range).
          Try p=0: lag=3, penalty = 680 * (ln(3/4))^2 = 680 * 0.083 = 56.2
                   score = dp[0] + O[3] - 56.2 = 0.1 + 0.8 - 56.2 = -55.3
          Try p=1: lag=2, penalty = 680 * (ln(2/4))^2 = 680 * 0.48 = 326.7
                   score = dp[1] + O[3] - 326.7 = 0.3 + 0.8 - 326.7 = -325.6
          Best: p=0 with score -55.3  (lag 3 is closer to T=4 than lag 2)
          dp[3] = -55.3,  prev[3] = 0

Frame 7:  Predecessors in [7-8, 7-2] = [0, 5] (clamped).
          Try p=3: lag=4, penalty = 680 * (ln(4/4))^2 = 680 * 0 = 0.0
                   score = dp[3] + O[7] - 0.0 = -55.3 + 0.9 - 0.0 = -54.4
          Perfect spacing! Zero penalty.
          dp[7] = -54.4,  prev[7] = 3

Frame 11: Predecessors in [11-8, 11-2] = [3, 9].
          Try p=7: lag=4, penalty = 0.0
                   score = dp[7] + O[11] - 0.0 = -54.4 + 0.7 - 0.0 = -53.7
          Again perfect spacing.
          dp[11] = -53.7,  prev[11] = 7


At each frame, the algorithm records:
    dp[t]   = best cumulative score achievable ending at frame t
    prev[t] = which predecessor frame gave that best score


After processing all frames, dp[] looks something like:

dp[t]
  |
  |                    *              *
  |                                         *
  |              *           *
  |  *     *           *
  |     *        *              *        *
  +--*-----*--*-----*-----*-----*--*--------*----> frames
     0  1  2  3  4  5  6  7  8  9  10 11

The highest values are at frames where beats naturally fall.


--------------------------------------------------------------------------------


STEP 4: BACKTRACE
------------------

Now we need to extract the actual beat sequence. We start near the END of
the signal and follow the prev[] pointers backward.

Why start near the end? Because the DP score is cumulative -- frames near
the end have had the most opportunities to build up a good sequence. Starting
from the best frame in the last 10% of the signal ensures we find a sequence
that worked well across the entire track.


    1. Find the frame with the highest dp[] score in the last 10% of frames.
    2. Follow prev[] pointers backward until we reach -1 (no predecessor).
    3. Reverse the sequence to get chronological order.


Example:

    Frames:     0    1    2    3    4    5    6    7    8    9   10   11
    prev[]:    -1   -1   -1    0   -1   -1    2    3   -1    5    6    7

    Start at frame 11 (best score in last 10%):

    Frame 11  -->  prev = 7
    Frame  7  -->  prev = 3
    Frame  3  -->  prev = 0
    Frame  0  -->  prev = -1  (stop)

    Reversed: [0, 3, 7, 11]

    Beat frames: 0, 3, 7, 11
    Spacings:      3  4  4      (close to T=4, as expected)


The backtrace naturally produces a sequence where:
    - Beats tend to land on strong onsets.
    - Beats are approximately evenly spaced at period T.
    - The ENTIRE sequence is globally optimal -- not just locally greedy.


--------------------------------------------------------------------------------


STEP 5: CONVERT TO SAMPLE POSITIONS
-------------------------------------

The beat tracker works in "onset frames" (one per hop). To get actual audio
sample positions:

    sample_position = frame_index * hop_size

Example with hop_size = 512:

    Beat frames:     [0,    3,    7,    11  ]
    Sample positions: [0, 1536, 3584, 5632]

These sample positions are what the metronome uses to know where to paste
its click sounds in the audio.

At 44100 Hz sample rate:

    Beat times:      [0.00s, 0.035s, 0.081s, 0.128s]
    (In a real song these would be much further apart, e.g. every ~0.5s
     for 120 BPM.)


--------------------------------------------------------------------------------


WHY DYNAMIC PROGRAMMING?
--------------------------

The brute-force approach would be: try every possible combination of beat
positions and score each one. For a 3-minute song at 86 frames/sec, that's
~15,000 frames. With ~350 beats to place, the number of combinations is
astronomical.

DP avoids this by exploiting the fact that the optimal sequence up to frame t
doesn't depend on what happens after t. At each frame, we only need to know
the best score achievable so far, not the full history. This reduces the
problem from exponential to O(N * W) where N is the number of frames and
W is the search window width (about 3*T frames).

For a typical song:  N = 15000, W = 130  -->  ~2 million operations.
That takes a few milliseconds.


--------------------------------------------------------------------------------


PUTTING IT ALL TOGETHER
------------------------

    Onset strength O[n]  +  period T = 43 frames (120 BPM)
            |
            v
    Forward pass: for each frame t = 0, 1, 2, ... N:
        search predecessors in [t - 86, t - 21]
        dp[t] = best of: dp[p] + O[t] - 680*(ln((t-p)/43))^2
        prev[t] = the p that gave the best score
            |
            v
    Backtrace: start at best frame in last 10%
        follow prev[] pointers: ... -> 387 -> 344 -> 301 -> 258 -> ...
            |
            v
    Reverse: [258, 301, 344, 387, ...]
        spacings: 43, 43, 43, ...  (perfect 120 BPM grid)
            |
            v
    Convert: [258*512, 301*512, 344*512, 387*512, ...]
           = [132096,  154112,  176128,  198144, ...]
            |
            v
    Output: beat sample positions --> passed to metronome for click overlay
