TEMPO ESTIMATOR -- STEP BY STEP
=================================


THE BIG PICTURE
---------------

The onset detector gave us a 1D signal -- the onset strength function O[n] --
with one value per frame (~86 frames/sec). It spikes at rhythmic events. Now
we need to answer: "how far apart are those spikes, on average?"

Onset strength function (input):
|
|          #           #           #           #
|          #           #           #     #     #
|     #    #     #     #     #     #     #     #     #
|     #    #     #     #     #     #     #     #     #
+-----#----#-----#-----#-----#-----#-----#-----#-----#-----> frames
      |              |              |              |
      |<--- T ------>|<--- T ------>|<--- T ------>|
                  beat period

The tempo estimator finds T (the beat period in frames), then converts it
to BPM:

    bpm = 60 * frame_rate / T

where frame_rate = sample_rate / hop_size (e.g. 44100 / 512 = 86.13 fps).


Onset strength O[n]
|
+-- Autocorrelation -----------------> R(lag) for each candidate lag
|                                        "how periodic is the signal at this spacing?"
|
+-- Tempo prior ---------------------> Weight R(lag) by how likely that BPM is
|                                        (log-Gaussian centered at 120 BPM)
|
+-- Octave correction ---------------> Escape sub-harmonic traps
|                                        (prefer 120 BPM over 60 BPM)
|
+-- Parabolic interpolation ---------> Refine lag to sub-frame precision
|
+-- Convert to BPM ------------------> bpm = 60 * frame_rate / refined_lag


--------------------------------------------------------------------------------


STEP 1: AUTOCORRELATION
------------------------

Autocorrelation asks: "if I shift the onset signal by L frames and overlay it
on top of itself, how well do the peaks line up?"

For each candidate lag L:

    R(L) = (1/count) * sum over n of: O[n] * O[n + L]

When the shift L matches the beat period, the peaks land on top of each other
and the products are large. When L is wrong, peaks land on valleys and the
products are small.


Example with a signal that repeats every 4 frames:

Original:   0  0  5  0  0  0  5  0  0  0  5  0  0  0  5  0
                  ^              ^              ^              ^

Lag = 4:    0  0  5  0  0  0  5  0  0  0  5  0
(shifted)            ^              ^              ^

Products:   0  0  0  0  0  0 25  0  0  0 25  0    <-- big numbers!
                                                    R(4) = high

Lag = 3:    0  0  5  0  0  0  5  0  0  0  5  0  0
(shifted)         ^              ^              ^

Products:   0  0  0  0  0  0  0  0  0  0  0  0  0  <-- all zeros
                                                    R(3) = low


The autocorrelation is computed for every lag in the valid range. The lag range
comes from the BPM range:

    min_lag = ceil(60 * frame_rate / max_bpm)     e.g. 220 BPM -> lag 23
    max_lag = floor(60 * frame_rate / min_bpm)    e.g.  50 BPM -> lag 103

So we compute R(23), R(24), R(25), ... R(103) and look for the biggest peak.

Normalization: each R(L) is divided by the number of terms that contributed
(count = N - L). Without this, longer lags would have fewer terms and appear
artificially weaker, biasing the result toward slow tempos.


R(lag)
|
|            #
|            #
|       #    #
|       #    #              #
|       #    #         #    #
|    #  #    #    #    #    #    #
+----#--#----#----#----#----#----#----> lag
     23      34        57        103
             ^         ^
             |         |
          true beat   sub-harmonic
          period      (double the period)


--------------------------------------------------------------------------------


STEP 2: TEMPO PRIOR
--------------------

The raw autocorrelation has a fundamental problem: if a signal repeats every
T frames, it also repeats every 2T, 3T, 4T frames. So R(lag) has peaks at the
true period AND at all its multiples. This is the "octave ambiguity" problem.

Example: a 120 BPM song (period = 43 frames at 86 fps):

R(lag)
|
|            #                                         #
|            #                                         #
|       #    #    #                               #    #    #
|    #  #    #    #  #                         #  #    #    #  #
+----#--#----#----#--#--..........................#--#----#----#--#----> lag
     |       43      |                         |       86       |
     |    true       |                      sub-harmonic     also a
     |    period     |                      (2T = 60 BPM)    peak!
     |               |
   nearby lags     nearby lags


Which peak should we pick? 43 (120 BPM) or 86 (60 BPM)? Both have strong
autocorrelation. The sub-harmonic at 86 might even be STRONGER because every
beat at period 43 also aligns at period 86.

The tempo prior biases toward musically common tempos. It's a Gaussian bell
curve on a log2(BPM) axis, centered at 120 BPM with sigma = 1 octave:

    weight(lag) = exp(-0.5 * (log2(bpm / 120))^2 / sigma^2)

This means:
    120 BPM  ->  weight = 1.0    (center, full weight)
     60 BPM  ->  weight = 0.61   (1 octave away, penalized)
    240 BPM  ->  weight = 0.61   (1 octave away, penalized)
     30 BPM  ->  weight = 0.14   (2 octaves away, heavily penalized)

The weighted score is:  W(lag) = R(lag) * weight(lag)

The log2 scale is important -- it means the prior is symmetric in musical
octaves. 60 BPM is as far from 120 as 240 is from 120 (one octave each way).
Using ln instead of log2 with the same sigma would make the prior much too
narrow, pulling everything toward 120 BPM regardless of the actual tempo.


Prior weight
|
|                  *
|                 * *
|                *   *
|               *     *
|             *         *
|           *             *
|        *                   *
|     *                         *
+--*------*-------*-------*-------*---> BPM
   30     60     120     240     480
                  ^
              center of prior


--------------------------------------------------------------------------------


STEP 3: OCTAVE CORRECTION
--------------------------

Even with the prior, sub-harmonic traps can persist. If the true tempo is
60 BPM, the prior helps pick it correctly. But if the true tempo is 120 BPM,
the sub-harmonic at 60 BPM still has strong autocorrelation AND a reasonable
prior weight (0.61). Sometimes the sub-harmonic wins.

The fix: iteratively try halving the best lag. If the half-lag also has a
strong peak, prefer it (faster tempo is usually more correct).

The algorithm:

    1. Start with best_lag (the lag with highest weighted score).
    2. Compute half_lag = best_lag / 2.
    3. Search a small window around half_lag: [half_lag - 2, half_lag + 2].
       (The +/-2 handles cases where the exact half doesn't fall on an
       integer lag.)
    4. If the best candidate in that window has a weighted score above the
       median noise floor, accept it as the new best_lag.
    5. Repeat from step 2 with the new best_lag.
    6. Stop when the half-lag is out of range or below the noise floor.


Example walkthrough:

    Initial best_lag = 86  (60 BPM, sub-harmonic)

    Iteration 1:
        half_lag = 43
        Search lags 41, 42, 43, 44, 45
        Lag 43 has weighted score 0.82 (above median of 0.15)
        Accept! best_lag = 43  (120 BPM, correct!)

    Iteration 2:
        half_lag = 21
        Search lags 19, 20, 21, 22, 23
        Lag 21 has weighted score 0.09 (below median of 0.15)
        Reject. Stop.

    Final answer: lag 43 = 120 BPM.


The median weighted score acts as a noise floor -- it separates real peaks
from autocorrelation noise. Without this threshold, the algorithm might keep
halving into meaningless lags.


--------------------------------------------------------------------------------


STEP 4: PARABOLIC INTERPOLATION
---------------------------------

At 44.1 kHz sample rate with hop size 512, adjacent lags differ by about
2.7 BPM. That's too coarse -- the difference between lag 43 (120.3 BPM) and
lag 44 (117.5 BPM) is nearly 3 BPM.

But the true peak of the autocorrelation usually falls between two integer
lags. Parabolic interpolation recovers the fractional position.

Take the three points around the peak and fit a parabola:

    R[peak-1],  R[peak],  R[peak+1]

             R[peak]
               *
              / \
             /   \
    R[peak-1]     R[peak+1]
        *             *
       /               \

    The parabola's vertex is at:
    delta = 0.5 * (R[peak-1] - R[peak+1]) / (R[peak-1] - 2*R[peak] + R[peak+1])

    refined_lag = peak + delta


Example:

    R[42] = 0.71,  R[43] = 0.85,  R[44] = 0.78

    delta = 0.5 * (0.71 - 0.78) / (0.71 - 2*0.85 + 0.78)
          = 0.5 * (-0.07) / (-0.21)
          = 0.167

    refined_lag = 43.167

    bpm = 60 * 86.13 / 43.167 = 119.7 BPM

Without interpolation: 60 * 86.13 / 43 = 120.2 BPM (rounded to nearest lag).
The interpolation gives sub-lag precision, typically within ~0.1 BPM accuracy.


--------------------------------------------------------------------------------


PUTTING IT ALL TOGETHER
------------------------

    Onset strength O[n]   (from onset detector)
            |
            v
    Autocorrelation R(lag) for lags 23..103
            |
            v
    Apply tempo prior:  W(lag) = R(lag) * gaussian(bpm(lag), center=120)
            |
            v
    Pick lag with highest W(lag)   -->  e.g. lag 86 (60 BPM)
            |
            v
    Octave correction: try lag 43  -->  strong peak? yes --> use lag 43
                       try lag 21  -->  strong peak? no  --> stop
            |
            v
    Parabolic interpolation around lag 43  -->  refined_lag = 43.17
            |
            v
    bpm = 60 * 86.13 / 43.17 = 119.7 BPM
    period_frames = 43


Output: BPM (float) and period_frames (int) are passed to the beat tracker.
